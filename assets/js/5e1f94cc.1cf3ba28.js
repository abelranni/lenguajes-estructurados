"use strict";(self.webpackChunklenguajes_estructurados=self.webpackChunklenguajes_estructurados||[]).push([[2385],{3905:(e,a,n)=>{n.d(a,{Zo:()=>c,kt:()=>k});var l=n(7294);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function t(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);a&&(l=l.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,l)}return n}function r(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?t(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,l,i=function(e,a){if(null==e)return{};var n,l,i={},t=Object.keys(e);for(l=0;l<t.length;l++)n=t[l],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(l=0;l<t.length;l++)n=t[l],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=l.createContext({}),s=function(e){var a=l.useContext(u),n=a;return e&&(n="function"==typeof e?e(a):r(r({},a),e)),n},c=function(e){var a=s(e.components);return l.createElement(u.Provider,{value:a},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return l.createElement(l.Fragment,{},a)}},m=l.forwardRef((function(e,a){var n=e.components,i=e.mdxType,t=e.originalType,u=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=s(n),m=i,k=d["".concat(u,".").concat(m)]||d[m]||p[m]||t;return n?l.createElement(k,r(r({ref:a},c),{},{components:n})):l.createElement(k,r({ref:a},c))}));function k(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var t=n.length,r=new Array(t);r[0]=m;var o={};for(var u in a)hasOwnProperty.call(a,u)&&(o[u]=a[u]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var s=2;s<t;s++)r[s]=n[s];return l.createElement.apply(null,r)}return l.createElement.apply(null,n)}m.displayName="MDXCreateElement"},138:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>u,contentTitle:()=>r,default:()=>p,frontMatter:()=>t,metadata:()=>o,toc:()=>s});var l=n(7462),i=(n(7294),n(3905));const t={marp:!0,theme:"default",size:969,paginate:!0},r="03.05 -  TicTacToe",o={unversionedId:"Ejercicios Resueltos/03.05_tictactoe",id:"Ejercicios Resueltos/03.05_tictactoe",title:"03.05 -  TicTacToe",description:"Lenguajes Estructurados",source:"@site/docs/03 - Ejercicios Resueltos/03.05_tictactoe.md",sourceDirName:"03 - Ejercicios Resueltos",slug:"/Ejercicios Resueltos/03.05_tictactoe",permalink:"/lenguajes-estructurados/docs/Ejercicios Resueltos/03.05_tictactoe",draft:!1,editUrl:"https://github.com/abelranni/lenguajes-estructurados/tree/main/docs/03 - Ejercicios Resueltos/03.05_tictactoe.md",tags:[],version:"current",frontMatter:{marp:!0,theme:"default",size:969,paginate:!0},sidebar:"tutorialSidebar",previous:{title:"03.03.B - Snake en Python",permalink:"/lenguajes-estructurados/docs/Ejercicios Resueltos/03.03.B_snake_py"},next:{title:"04 - Redes",permalink:"/lenguajes-estructurados/docs/category/04---redes"}},u={},s=[{value:"Lenguajes Estructurados",id:"lenguajes-estructurados",level:2},{value:"Introducci\xf3n",id:"introducci\xf3n",level:2},{value:"Especificaciones",id:"especificaciones",level:2},{value:"Requisitos previos",id:"requisitos-previos",level:2},{value:"Compilaci\xf3n del programa",id:"compilaci\xf3n-del-programa",level:2},{value:"Explicaci\xf3n del c\xf3digo",id:"explicaci\xf3n-del-c\xf3digo",level:2},{value:"Inclusi\xf3n de bibliotecas",id:"inclusi\xf3n-de-bibliotecas",level:3},{value:"variables globales",id:"variables-globales",level:3},{value:"Funciones auxiliares",id:"funciones-auxiliares",level:3},{value:"Funci\xf3n principal - WinMain()",id:"funci\xf3n-principal---winmain",level:3},{value:"Funci\xf3n load_texture()",id:"funci\xf3n-load_texture",level:3},{value:"Funci\xf3n add_piece()",id:"funci\xf3n-add_piece",level:3},{value:"Funci\xf3n init()",id:"funci\xf3n-init",level:3},{value:"Funci\xf3n clean_up()",id:"funci\xf3n-clean_up",level:3},{value:"Funci\xf3n draw_piece()",id:"funci\xf3n-draw_piece",level:3},{value:"Funci\xf3n draw_board()",id:"funci\xf3n-draw_board",level:3},{value:"Funci\xf3n WinMain()",id:"funci\xf3n-winmain",level:3},{value:"Algorigmo de Minimax",id:"algorigmo-de-minimax",level:3},{value:"Implementaci\xf3n de funciones <code>ia_move_minimax</code> y <code>minimax</code>",id:"implementaci\xf3n-de-funciones-ia_move_minimax-y-minimax",level:2},{value:"Fundamentos del algoritmo Minimax",id:"fundamentos-del-algoritmo-minimax",level:3},{value:"Implementaci\xf3n de <code>ia_move_minimax</code>",id:"implementaci\xf3n-de-ia_move_minimax",level:3},{value:"Implementaci\xf3n de <code>minimax</code>",id:"implementaci\xf3n-de-minimax",level:3},{value:"Archivos Fuente",id:"archivos-fuente",level:2},{value:"Archivos de Configuracion para Compilar y Depurar",id:"archivos-de-configuracion-para-compilar-y-depurar",level:2}],c={toc:s},d="wrapper";function p(e){let{components:a,...t}=e;return(0,i.kt)(d,(0,l.Z)({},c,t,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0305----tictactoe"},"03.05 -  TicTacToe"),(0,i.kt)("h2",{id:"lenguajes-estructurados"},"Lenguajes Estructurados"),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"introducci\xf3n"},"Introducci\xf3n"),(0,i.kt)("p",null,"El objetivo de este trabajo pr\xe1ctico es desarrollar un juego de tres en l\xednea utilizando la biblioteca gr\xe1fica SDL2."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"especificaciones"},"Especificaciones"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"El juego debe permitir jugar contra la computadora o contra otro jugador.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"El juego debe permitir elegir el s\xedmbolo que utilizar\xe1 cada jugador (X, O, etc.)."))),(0,i.kt)("h2",{id:"requisitos-previos"},"Requisitos previos"),(0,i.kt)("p",null,"Tener instalado un compilador de C, como GCC (GNU Compiler Collection), en tu sistema.\nInstala las siguientes bibliotecas SDL:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SDL2"),(0,i.kt)("li",{parentName:"ul"},"SDL2_image"),(0,i.kt)("li",{parentName:"ul"},"SDL2_ttf")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Para instalar las bibliotecas en sistemas basados en Debian/Ubuntu, ejecuta los siguientes comandos:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"sudo apt-get update\nsudo apt-get install libsdl2-dev libsdl2-image-dev libsdl2-ttf-dev\n")),(0,i.kt)("h2",{id:"compilaci\xf3n-del-programa"},"Compilaci\xf3n del programa"),(0,i.kt)("p",null,"Para compilar el programa, ejecuta el siguiente comando en la terminal desde el directorio donde se encuentra el archivo ttt.c:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"gcc .\\ttt.c -o ttt.exe -lSDL2 -lSDL2_ttf -lSDL2_image\n")),(0,i.kt)("p",null,"Esto generar\xe1 un ejecutable llamado ttt.exe."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"explicaci\xf3n-del-c\xf3digo"},"Explicaci\xf3n del c\xf3digo"),(0,i.kt)("h3",{id:"inclusi\xf3n-de-bibliotecas"},"Inclusi\xf3n de bibliotecas"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL2/SDL_ttf.h>\n#include <stdio.h>\n")),(0,i.kt)("p",null,"Se incluyen las bibliotecas necesarias para utilizar SDL2, SDL_image y SDL_ttf. Tambi\xe9n se incluye la biblioteca est\xe1ndar de E/S para imprimir mensajes de error si los hubiera."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"variables-globales"},"variables globales"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"const int SCREEN_WIDTH = 640;\nconst int SCREEN_HEIGHT = 480;\n\nSDL_Window *window = NULL;\nSDL_Renderer *renderer = NULL;\n\nint board[3][3] = {0};\n\nSDL_Texture *player1_texture = NULL;\nSDL_Texture *player2_texture = NULL;\n")),(0,i.kt)("p",null,"Se declaran las constantes para el ancho y alto de la pantalla, as\xed como las variables globales para la ventana y el renderizador de SDL. Tambi\xe9n se declara una matriz 3x3 llamada board que representa el estado del tablero y las texturas para las fichas de los jugadores 1 y 2."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funciones-auxiliares"},"Funciones auxiliares"),(0,i.kt)("p",null,"El programa incluye varias funciones auxiliares, como load_texture(), add_piece(), init(), clean_up(), draw_piece() y draw_board().\nEstas funciones se utilizan para cargar texturas, agregar fichas al tablero, inicializar y limpiar recursos SDL, y dibujar las piezas y el tablero en la pantalla."),(0,i.kt)("h3",{id:"funci\xf3n-principal---winmain"},"Funci\xf3n principal - WinMain()"),(0,i.kt)("p",null,"La funci\xf3n principal WinMain() inicializa SDL y las bibliotecas auxiliares, carga las texturas de las fichas y entra en un bucle principal. En este bucle, se manejan los eventos de entrada del usuario y se dibuja el tablero en la pantalla."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"El bucle principal maneja eventos de cierre de ventana y eventos de clic del rat\xf3n."),(0,i.kt)("p",null,"Cuando se detecta un clic del rat\xf3n, se calcula la posici\xf3n del tablero en la que se hizo clic y se intenta agregar una ficha en esa posici\xf3n."),(0,i.kt)("p",null,"Si se puede agregar una ficha, el jugador actual cambia al otro jugador."),(0,i.kt)("p",null,"Finalmente, se llama a clean_up() para liberar los recursos de SDL antes de que el programa termine"),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funci\xf3n-load_texture"},"Funci\xf3n load_texture()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'SDL_Texture *load_texture(const char *path)\n{\n    SDL_Surface *loaded_surface = IMG_Load(path);\n    if (!loaded_surface)\n    {\n        printf("Error al cargar la imagen %s: %s\\n", path, IMG_GetError());\n        return NULL;\n    }\n\n    SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer, loaded_surface);\n    if (!texture)\n    {\n        printf("Error al crear la textura a partir de %s: %s\\n", path, SDL_GetError());\n    }\n\n    SDL_FreeSurface(loaded_surface);\n\n    return texture;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"SDL_Texture *load_texture(const char *path)\n")),(0,i.kt)("p",null,"Descripci\xf3n: Carga una textura desde un archivo de imagen."),(0,i.kt)("p",null,"Argumentos:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"const char *path: Ruta al archivo de imagen.")),(0,i.kt)("p",null,"Valor de retorno:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Un puntero a la textura cargada o NULL si hay un error.")),(0,i.kt)("p",null,"Detalles de implementaci\xf3n:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Carga la superficie de la imagen utilizando IMG_Load()."),(0,i.kt)("li",{parentName:"ul"},"Crea una textura a partir de la superficie cargada utilizando SDL_CreateTextureFromSurface()."),(0,i.kt)("li",{parentName:"ul"},"Libera la superficie cargada utilizando SDL_FreeSurface()."),(0,i.kt)("li",{parentName:"ul"},"Retorna la textura creada.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funci\xf3n-add_piece"},"Funci\xf3n add_piece()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"\nint add_piece(int x, int y, int player)\n{\n    if (x < 0 || x > 2 || y < 0 || y > 2)\n    {\n        return 0;\n    }\n\n    if (board[x][y] != 0)\n    {\n        return 0;\n    }\n\n    board[x][y] = player;\n\n    return 1;\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int add_piece(int x, int y, int player)\n")),(0,i.kt)("p",null,"Descripci\xf3n: Agrega una ficha en la posici\xf3n (x, y) del tablero."),(0,i.kt)("p",null,"Argumentos:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"int x: Coordenada X de la posici\xf3n del tablero."),(0,i.kt)("li",{parentName:"ul"},"int y: Coordenada Y de la posici\xf3n del tablero."),(0,i.kt)("li",{parentName:"ul"},"int player: N\xfamero del jugador (1 o 2).")),(0,i.kt)("p",null,"Valor de retorno:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"1 si se pudo agregar la ficha"),(0,i.kt)("li",{parentName:"ul"},"0 en caso contrario.")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Detalles de implementaci\xf3n:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Verifica si las coordenadas (x, y) est\xe1n dentro del rango del tablero y si la casilla est\xe1 vac\xeda."),(0,i.kt)("li",{parentName:"ul"},"Si se cumplen las condiciones, coloca la ficha del jugador en la posici\xf3n (x, y) y retorna 1."),(0,i.kt)("li",{parentName:"ul"},"Si no se cumplen las condiciones, retorna 0")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funci\xf3n-init"},"Funci\xf3n init()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'\nint init()\n{\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) {\n        printf("Error al inicializar SDL: %s\\n", SDL_GetError());\n        return 0;\n    }\n    window = SDL_CreateWindow("Tateti", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    if (!window) {\n        printf("Error al crear la ventana: %s\\n", SDL_GetError());\n        return 0;\n    }\n    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n    if (!renderer) {\n        printf("Error al crear el renderizador: %s\\n", SDL_GetError());\n        return 0;\n    }\n    if (IMG_Init(IMG_INIT_PNG) != IMG_INIT_PNG) {\n        printf("Error al inicializar SDL_image: %s\\n", IMG_GetError());\n        return 0;\n    }\n    if (TTF_Init() < 0) {\n        printf("Error al inicializar SDL_ttf: %s\\n", TTF_GetError());\n        return 0;\n    }\n    return 1;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int init()\n")),(0,i.kt)("p",null,"Descripci\xf3n: Inicializa SDL y las bibliotecas auxiliares."),(0,i.kt)("p",null,"Valor de retorno:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"1 si la inicializaci\xf3n fue exitosa"),(0,i.kt)("li",{parentName:"ul"},"0 en caso contrario.")),(0,i.kt)("p",null,"Detalles de implementaci\xf3n:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Inicializa SDL con el subsistema de video."),(0,i.kt)("li",{parentName:"ul"},"Crea la ventana SDL."),(0,i.kt)("li",{parentName:"ul"},"Crea el renderizador SDL."),(0,i.kt)("li",{parentName:"ul"},"Inicializa SDL_image con soporte para im\xe1genes PNG."),(0,i.kt)("li",{parentName:"ul"},"Inicializa SDL_ttf.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funci\xf3n-clean_up"},"Funci\xf3n clean_up()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"\nvoid clean_up()\n{\n    SDL_DestroyTexture(player1_texture);\n    SDL_DestroyTexture(player2_texture);\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(window);\n    IMG_Quit();\n    SDL_Quit();\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void clean_up()\n")),(0,i.kt)("p",null,"Descripci\xf3n: Libera los recursos de SDL y las bibliotecas auxiliares."),(0,i.kt)("p",null,"Detalles de implementaci\xf3n:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Destruye el renderizador y la ventana de SDL."),(0,i.kt)("li",{parentName:"ul"},"Finaliza SDL_ttf, SDL_image y SDL.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funci\xf3n-draw_piece"},"Funci\xf3n draw_piece()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"\nvoid draw_piece(SDL_Texture *texture, int x, int y)\n\n{\n    SDL_Rect dest_rect;\n    dest_rect.x = x * (SCREEN_WIDTH / 3) + (SCREEN_WIDTH / 6);\n    dest_rect.y = y * (SCREEN_HEIGHT / 3) + (SCREEN_HEIGHT / 6);\n    dest_rect.w = 32;\n    dest_rect.h = 32;\n\n    SDL_RenderCopy(renderer, texture, NULL, &dest_rect);\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"\nvoid draw_piece(SDL_Texture *texture, int x, int y)\n")),(0,i.kt)("p",null,"Descripci\xf3n: Dibuja una ficha en la posici\xf3n (x, y) del tablero."),(0,i.kt)("p",null,"Argumentos:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SDL_Texture *texture: Textura de la ficha a dibujar."),(0,i.kt)("li",{parentName:"ul"},"int x: Coordenada X de la posici\xf3n del tablero."),(0,i.kt)("li",{parentName:"ul"},"int y: Coordenada Y de la posici\xf3n del tablero.")),(0,i.kt)("p",null,"Detalles de implementaci\xf3n:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Establece las coordenadas y el tama\xf1o del rect\xe1ngulo de destino en funci\xf3n de las coordenadas del tablero y el tama\xf1o de la pantalla."),(0,i.kt)("li",{parentName:"ul"},"Copia la textura en el rect\xe1ngulo de destino utilizando SDL_RenderCopy().")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funci\xf3n-draw_board"},"Funci\xf3n draw_board()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"\nvoid draw_board()\n{\n    SDL_SetRenderDrawColor(renderer, 0xFF, 0xFF, 0xFF, 0xFF);\n    SDL_RenderClear(renderer);\n\n    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0xFF);\n    for (int i = 1; i < 3; ++i)\n    {\n        SDL_RenderDrawLine(renderer, i * SCREEN_WIDTH / 3, 0, i * SCREEN_WIDTH / 3, SCREEN_HEIGHT);\n        SDL_RenderDrawLine(renderer, 0, i * SCREEN_HEIGHT / 3, SCREEN_WIDTH, i * SCREEN_HEIGHT / 3);\n    }\n\n    // Dibujar las fichas en el tablero\n    for (int i = 0; i < 3; ++i)\n    {\n        for (int j = 0; j < 3; ++j)\n        {\n            if (board[i][j] == 1)\n            {\n                draw_piece(player1_texture, i, j);\n            }\n            else if (board[i][j] == 2)\n            {\n                draw_piece(player2_texture, i, j);\n            }\n        }\n    }\n\n    SDL_RenderPresent(renderer);\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void draw_board()\n")),(0,i.kt)("p",null,"Descripci\xf3n: Dibuja el tablero y las fichas en la pantalla."),(0,i.kt)("p",null,"Detalles de implementaci\xf3n:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Establece el color de fondo y borra la pantalla utilizando SDL_RenderClear()."),(0,i.kt)("li",{parentName:"ul"},"Establece el color de las l\xedneas del tablero y dibuja las l\xedneas utilizando SDL_RenderDrawLine()."),(0,i.kt)("li",{parentName:"ul"},"Itera a trav\xe9s de todas las posiciones del tablero y dibuja las fichas de los jugadores utilizando draw_piece():"),(0,i.kt)("li",{parentName:"ul"},"Si board","[i][j]"," es 1, dibuja la ficha del jugador 1 en la posici\xf3n (i, j)."),(0,i.kt)("li",{parentName:"ul"},"Si board","[i][j]"," es 2, dibuja la ficha del jugador 2 en la posici\xf3n (i, j)."),(0,i.kt)("li",{parentName:"ul"},"Actualiza la pantalla utilizando SDL_RenderPresent().")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"funci\xf3n-winmain"},"Funci\xf3n WinMain()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'int WinMain(int argc, char *args[])\n{\n    if (!init()) {\n        printf("Error al inicializar.\\n");\n    }\n    else {\n        player1_texture = load_texture("rojo.png");\n        player2_texture = load_texture("verde.png");\n        if (!player1_texture || !player2_texture) {\n            printf("Error al cargar las texturas de las fichas.\\n");\n        }\n        else {\n            int quit = 0;\n            SDL_Event e;\n            int currentPlayer = 1;\n\n            while (!quit)\n            {\n                while (SDL_PollEvent(&e) != 0)\n                {\n                    if (e.type == SDL_QUIT) {\n                        quit = 1;\n                    }\n                    if (e.type == SDL_MOUSEBUTTONDOWN) {\n                        int x = e.button.x / (SCREEN_WIDTH / 3);\n                        int y = e.button.y / (SCREEN_HEIGHT / 3);\n                        if (add_piece(x, y, currentPlayer)) {\n                            currentPlayer = (currentPlayer == 1) ? 2 : 1; // Cambiar el jugador actual\n                        }\n                    }\n                }\n                draw_board();\n                SDL_RenderPresent(renderer);\n            }\n        }\n    }\n    clean_up();\n    return 0;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int WinMain()\n")),(0,i.kt)("p",null,"Descripci\xf3n: La funci\xf3n principal del programa."),(0,i.kt)("p",null,"Detalles de implementaci\xf3n:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Llama a init() para inicializar SDL y las bibliotecas auxiliares."),(0,i.kt)("li",{parentName:"ul"},"Carga las texturas de las fichas de los jugadores 1 y 2 utilizando load_texture().")),(0,i.kt)("hr",null),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Si las texturas se cargaron correctamente, entra en un bucle principal:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Maneja los eventos de entrada del usuario utilizando SDL_PollEvent():",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Si el evento es de tipo SDL_QUIT, establece quit en 1 para salir del bucle principal."),(0,i.kt)("li",{parentName:"ul"},"Si el evento es de tipo SDL_MOUSEBUTTONDOWN, calcula la posici\xf3n del tablero en la que se hizo clic y llama a add_piece() para agregar una ficha en esa posici\xf3n."),(0,i.kt)("li",{parentName:"ul"},"Si se pudo agregar una ficha, cambia el jugador actual al otro jugador."))),(0,i.kt)("li",{parentName:"ul"},"Llama a draw_board() para dibujar el tablero y las fichas en la pantalla."),(0,i.kt)("li",{parentName:"ul"},"Actualiza la pantalla utilizando SDL_RenderPresent()."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Llama a clean_up() para liberar los recursos de SDL antes de que el programa termine."))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"algorigmo-de-minimax"},"Algorigmo de Minimax"),(0,i.kt)("p",null,"El algoritmo Minimax es un algoritmo de b\xfasqueda recursiva que se utiliza para determinar el mejor movimiento en un juego con dos jugadores que se turnan (como el tres en l\xednea)."),(0,i.kt)("p",null,"Minimax asigna un valor a cada movimiento posible. El jugador que maximiza (Max) intenta obtener el mayor valor posible, mientras que el jugador que minimiza (Min) intenta obtener el menor valor posible."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"En el tres en l\xednea, se puede asignar un valor de +10 a un estado de ganar para el jugador Max, -10 a un estado de ganar para el jugador Min y 0 a un empate.\nEl algoritmo decidir\xe1 el mejor movimiento bas\xe1ndose en estos valores."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Primero, hace falta implementar tres funciones adicionales:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"is_winner(int player) verifica si un jugador ha ganado el juego."),(0,i.kt)("li",{parentName:"ul"},"is_full_board() verifica si el tablero est\xe1 lleno (es decir, si no quedan movimientos posibles)."),(0,i.kt)("li",{parentName:"ul"},"minimax(int depth, int isMaxPlayer) eval\xfaa recursivamente los movimientos posibles y devuelve el mejor valor posible."),(0,i.kt)("li",{parentName:"ul"},"is_empty(int x, int y) verifica si una casilla est\xe1 vac\xeda"),(0,i.kt)("li",{parentName:"ul"},"remove_piece(int x, int y) para deshacer un movimiento")),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int is_winner(int player)\n{\n    // Verifica filas, columnas y diagonales para ver si el jugador ha ganado\n    // Retorna 1 si el jugador ha ganado, 0 en caso contrario\n}\n\nint is_full_board()\n{\n    // Verifica si el tablero est\xe1 lleno\n    // Retorna 1 si el tablero est\xe1 lleno, 0 en caso contrario\n}\n\nint is_empty(int x, int y)\n{\n    // Verifica si la casilla (x, y) est\xe1 vac\xeda\n    // Retorna 1 si la casilla est\xe1 vac\xeda, 0 en caso contrario\n}\n\nvoid remove_piece(int x, int y)\n{\n    // Elimina la pieza en la posici\xf3n (x, y)\n}\n\n")),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int minimax(int depth, int isMaxPlayer)\n{\n    // Si alguien gan\xf3 o si el tablero est\xe1 lleno, retorna el valor correspondiente\n    if (is_winner(1))\n        return 10 - depth;\n    if (is_winner(2))\n        return -10 + depth;\n    if (is_full_board())\n        return 0;\n\n    int bestValue;\n    if (isMaxPlayer)\n    {\n        bestValue = -1000; // Inicializa el mejor valor para Max en un valor muy bajo\n        // Itera a trav\xe9s de todos los movimientos posibles\n        // ... Realiza el movimiento\n        // ... Llama a minimax() recursivamente con el siguiente jugador\n        // ... Deshace el movimiento\n        // ... Compara y actualiza el mejor valor\n    }\n    else\n    {\n        bestValue = 1000; // Inicializa el mejor valor para Min en un valor muy alto\n        // Itera a trav\xe9s de todos los movimientos posibles\n        // ... Realiza el movimiento\n        // ... Llama a minimax() recursivamente con el siguiente jugador\n        // ... Deshace el movimiento\n        // ... Compara y actualiza el mejor valor\n    }\n    return bestValue;\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Luego, modificar la funci\xf3n ia_move() para utilizar el algoritmo Minimax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void ia_move(int currentPlayer)\n{\n    int bestValue = 1000; // Inicializa el mejor valor en un valor muy alto\n    int bestMoveX = -1;\n    int bestMoveY = -1;\n\n    // Itera a trav\xe9s de todos los movimientos posibles\n    for (int x = 0; x < 3; x++)\n    {\n        for (int y = 0; y < 3; y++)\n        {\n            // Comprueba si la casilla (x, y) est\xe1 vac\xeda\n            if (is_empty(x, y))\n            {\n                // Realiza el movimiento\n                add_piece(x, y, currentPlayer);\n\n                // Calcula el valor minimax del movimiento\n                int moveValue = minimax(0, 1); // El jugador humano es el jugador Max (1)\n\n                // Deshace el movimiento\n                remove_piece(x, y);\n\n                // Compara y actualiza el mejor valor y la mejor posici\xf3n\n                if (moveValue < bestValue)\n                {\n                    bestValue = moveValue;\n                    bestMoveX = x;\n                    bestMoveY = y;\n                }\n            }\n        }\n    }\n\n    // Realiza el mejor movimiento encontrado\n    add_piece(bestMoveX, bestMoveY, currentPlayer);\n}\n")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"implementaci\xf3n-de-funciones-ia_move_minimax-y-minimax"},"Implementaci\xf3n de funciones ",(0,i.kt)("inlineCode",{parentName:"h2"},"ia_move_minimax")," y ",(0,i.kt)("inlineCode",{parentName:"h2"},"minimax")),(0,i.kt)("p",null,"Explicamos paso a paso la implementaci\xf3n de las funciones del algoritmo, comenzando con algunos conceptos b\xe1sicos del algoritmo Minimax y luego describiendo c\xf3mo se implementan en el c\xf3digo."),(0,i.kt)("h3",{id:"fundamentos-del-algoritmo-minimax"},"Fundamentos del algoritmo Minimax"),(0,i.kt)("p",null,"El algoritmo Minimax es una t\xe9cnica de b\xfasqueda en \xe1rbol utilizada en juegos de dos jugadores con informaci\xf3n perfecta, como Tic-Tac-Toe."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"La idea detr\xe1s de Minimax es simular todos los posibles movimientos que pueden hacer tanto el jugador como el oponente, y luego elegir el movimiento que maximice la posibilidad de ganar y minimice la posibilidad de perder.")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"El algoritmo funciona de manera recursiva, donde cada llamada a la funci\xf3n Minimax representa un movimiento en el \xe1rbol de juego. "),(0,i.kt)("p",null,"Los nodos en el \xe1rbol de juego representan diferentes estados del tablero de juego."),(0,i.kt)("p",null,'La funci\xf3n Minimax devuelve un valor que indica qu\xe9 tan "bueno" es un movimiento dado para el jugador actual.'),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"implementaci\xf3n-de-ia_move_minimax"},"Implementaci\xf3n de ",(0,i.kt)("inlineCode",{parentName:"h3"},"ia_move_minimax")),(0,i.kt)("p",null,"La funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"ia_move_minimax")," se utiliza para encontrar el mejor movimiento para la IA utilizando el algoritmo Minimax."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void ia_move_minimax(int currentPlayer)\n{\n    int best_value = -10000;\n    int best_x = -1;\n    int best_y = -1;\n")),(0,i.kt)("p",null,"Inicialmente, establecemos ",(0,i.kt)("inlineCode",{parentName:"p"},"best_value")," en un valor muy peque\xf1o (-10000) para asegurarnos de que cualquier valor que obtengamos del algoritmo Minimax sea mayor que este valor inicial."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Las variables ",(0,i.kt)("inlineCode",{parentName:"p"},"best_x")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"best_y")," almacenar\xe1n las coordenadas del mejor movimiento encontrado por la IA."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    for (int i = 0; i < 3; ++i)\n    {\n        for (int j = 0; j < 3; ++j)\n        {\n            if (board[i][j] == 0)\n            {\n                board[i][j] = currentPlayer;\n                int value = minimax(board, 0, 0);\n                board[i][j] = 0;\n")),(0,i.kt)("p",null,"Recorremos todas las casillas del tablero y, si encontramos una casilla vac\xeda (sin ficha), simulamos un movimiento colocando la ficha del jugador actual (IA) en esa casilla. "),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Luego, llamamos a la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," para evaluar el valor de este movimiento. Despu\xe9s de evaluar el movimiento, revertimos el cambio en el tablero (quitamos la ficha de la casilla)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"                if (value > best_value)\n                {\n                    best_value = value;\n                    best_x = i;\n                    best_y = j;\n                }\n            }\n        }\n    }\n")),(0,i.kt)("p",null,"Si el valor obtenido de la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," es mayor que el mejor valor actual, actualizamos el ",(0,i.kt)("inlineCode",{parentName:"p"},"best_value")," y las coordenadas ",(0,i.kt)("inlineCode",{parentName:"p"},"best_x")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"best_y"),"."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    if (best_x != -1 && best_y != -1)\n    {\n        add_piece(best_x, best_y, currentPlayer);\n    }\n}\n")),(0,i.kt)("p",null,"Una vez que hemos explorado todos los posibles movimientos, realizamos el mejor movimiento encontrado colocando la ficha en las coordenadas ",(0,i.kt)("inlineCode",{parentName:"p"},"best_x")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"best_y"),"."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"implementaci\xf3n-de-minimax"},"Implementaci\xf3n de ",(0,i.kt)("inlineCode",{parentName:"h3"},"minimax")),(0,i.kt)("p",null,"La funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," es la implementaci\xf3n del algoritmo Minimax propiamente dicho."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int minimax(int depth, int is_maximizing, int player)\n{\n")),(0,i.kt)("p",null,"La funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," toma tres argumentos: ",(0,i.kt)("inlineCode",{parentName:"p"},"depth"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"is_maximizing")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"player"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"depth")," representa la profundidad actual en el \xe1rbol de b\xfasqueda, ",(0,i.kt)("inlineCode",{parentName:"p"},"is_maximizing")," es un booleano que indica si el jugador actual est\xe1 maximizando o minimizando, y ",(0,i.kt)("inlineCode",{parentName:"p"},"player")," es el jugador para el que estamos buscando el mejor movimiento (1 o 2)."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    int winner = check_winner();\n    if (winner != 0)\n    {\n        return winner == player ? 1 : -1;\n    }\n")),(0,i.kt)("p",null,"Se llama a la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"check_winner")," para verificar si hay un ganador en el estado actual del tablero."),(0,i.kt)("p",null,"Si hay un ganador, la funci\xf3n devuelve un valor que indica qu\xe9 tan bueno es el estado actual del tablero para el jugador ",(0,i.kt)("inlineCode",{parentName:"p"},"player"),". "),(0,i.kt)("p",null,"Si ",(0,i.kt)("inlineCode",{parentName:"p"},"player")," es el ganador, la funci\xf3n devuelve 1; si el oponente es el ganador, devuelve -1."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    if (is_full())\n    {\n        return 0;\n    }\n")),(0,i.kt)("p",null,"Se llama a la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"is_full")," para verificar si el tablero est\xe1 lleno y no hay m\xe1s movimientos posibles."),(0,i.kt)("p",null,"Si el tablero est\xe1 lleno, entonces el juego ha terminado en empate y se devuelve un valor de 0."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Si el juego no ha terminado, evaluamos todos los movimientos posibles para el jugador actual."),(0,i.kt)("p",null,"La funci\xf3n Minimax se llama recursivamente para cada movimiento posible, y la profundidad aumenta en 1 en cada llamada recursiva."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Si el jugador actual es el jugador maximizador (IA), buscamos el movimiento con el mayor valor posible.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Si el jugador actual es el jugador minimizador (oponente), buscamos el movimiento con el menor valor posible."))),(0,i.kt)("p",null,"Para cada movimiento, actualizamos el tablero, llamamos a la funci\xf3n Minimax y luego revertimos el cambio en el tablero."),(0,i.kt)("p",null,"Al final, la funci\xf3n Minimax devuelve el mejor valor encontrado para el jugador actual en funci\xf3n de si es un jugador maximizador o minimizador."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    int best_value = is_maximizing ? -1000 : 1000;\n    int opponent = player == 1 ? 2 : 1;\n")),(0,i.kt)("p",null,"Se inicializa la variable ",(0,i.kt)("inlineCode",{parentName:"p"},"best_value")," con un valor extremo, dependiendo de si el jugador actual es maximizador o minimizador. Tambi\xe9n se calcula el n\xfamero del oponente (1 o 2)."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    for (int i = 0; i < 3; ++i)\n    {\n        for (int j = 0; j < 3; ++j)\n        {\n            if (board[i][j] == 0)\n            {\n")),(0,i.kt)("p",null,"Se itera a trav\xe9s de todas las casillas del tablero en busca de casillas vac\xedas."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"                board[i][j] = is_maximizing ? player : opponent;\n                int value = minimax(depth + 1, !is_maximizing, player);\n                board[i][j] = 0;\n")),(0,i.kt)("p",null,"Para cada casilla vac\xeda, se coloca temporalmente la ficha del jugador actual en la casilla y se llama a la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," recursivamente, aumentando la profundidad y alternando entre el jugador maximizador y minimizador."),(0,i.kt)("p",null,"Luego, se deshace el movimiento temporal en el tablero."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"                best_value = is_maximizing ? fmax(best_value, value) : fmin(best_value, value);\n            }\n        }\n    }\n")),(0,i.kt)("p",null,"Se actualiza el valor de ",(0,i.kt)("inlineCode",{parentName:"p"},"best_value")," utilizando la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"fmax")," o ",(0,i.kt)("inlineCode",{parentName:"p"},"fmin")," en funci\xf3n de si el jugador actual es maximizador o minimizador."),(0,i.kt)("hr",null),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"    return best_value;\n}\n")),(0,i.kt)("p",null,"Finalmente, se devuelve el valor de ",(0,i.kt)("inlineCode",{parentName:"p"},"best_value"),", que representa el valor \xf3ptimo del estado actual del tablero para el jugador ",(0,i.kt)("inlineCode",{parentName:"p"},"player"),"."),(0,i.kt)("p",null,"La funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," explora exhaustivamente todas las posibles secuencias de movimientos en el juego de Tic-Tac-Toe hasta que encuentra un estado terminal (es decir, un estado donde el juego ha terminado), y luego asigna un valor a ese estado seg\xfan si es favorable para el jugador ",(0,i.kt)("inlineCode",{parentName:"p"},"player")," (1), favorable para el oponente (-1) o un empate (0)."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"El algoritmo Minimax se basa en la suposici\xf3n de que ambos jugadores actuar\xe1n de manera \xf3ptima para maximizar su propio beneficio y minimizar el beneficio de su oponente."),(0,i.kt)("p",null,"Por lo tanto, durante la exploraci\xf3n del \xe1rbol de b\xfasqueda, la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," alterna entre maximizar y minimizar los valores de los estados del tablero."),(0,i.kt)("p",null,"Al final de la exploraci\xf3n, la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"minimax")," devuelve el valor \xf3ptimo del estado actual del tablero para el jugador ",(0,i.kt)("inlineCode",{parentName:"p"},"player"),"."),(0,i.kt)("p",null,"Este valor se utiliza en combinaci\xf3n con la funci\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"ia_move_minimax")," para determinar el mejor movimiento que el jugador controlado por IA debe realizar."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"archivos-fuente"},"Archivos Fuente"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(7966).Z},"tateti.h")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(6512).Z},"tateti.c")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(9741).Z},"rojo.png")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(7185).Z},"verde.png"))),(0,i.kt)("h2",{id:"archivos-de-configuracion-para-compilar-y-depurar"},"Archivos de Configuracion para Compilar y Depurar"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(6690).Z},"launch.json")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{target:"_blank",href:n(3531).Z},"tasks.json"))),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Los archivos de configuraci\xf3n debe ir dentro de una carpeta oculta llamada ",(0,i.kt)("inlineCode",{parentName:"p"},".vscode")," en la ra\xedz del proyecto."),(0,i.kt)("p",{parentName:"admonition"},"Cambiar la ruta de ",(0,i.kt)("strong",{parentName:"p"},"gdb.exe")," y ",(0,i.kt)("strong",{parentName:"p"},"gcc.exe")," seg\xfan corresponda")),(0,i.kt)("hr",null))}p.isMDXComponent=!0},6690:(e,a,n)=>{n.d(a,{Z:()=>l});const l=n.p+"assets/files/launch-1c2861d594a692d172e969a4b0573350.json"},9741:(e,a,n)=>{n.d(a,{Z:()=>l});const l=n.p+"assets/files/rojo-a9cc4d0072161b3fcd7fd0c7c477b3a0.png"},3531:(e,a,n)=>{n.d(a,{Z:()=>l});const l=n.p+"assets/files/tasks-5045e486b54f6dcf14f105b1e8096c17.json"},6512:(e,a,n)=>{n.d(a,{Z:()=>l});const l=n.p+"assets/files/tateti-80f6cc6a0a3af37bfbd01ef420e0808d.c"},7966:(e,a,n)=>{n.d(a,{Z:()=>l});const l=n.p+"assets/files/tateti-dad3a0ddd06faeade743fbf15e576f23.h"},7185:(e,a,n)=>{n.d(a,{Z:()=>l});const l=n.p+"assets/files/verde-157a07b2288f67edcd6763cc2abe56b7.png"}}]);