"use strict";(self.webpackChunklenguajes_estructurados=self.webpackChunklenguajes_estructurados||[]).push([[1075],{3905:(e,a,n)=>{n.d(a,{Zo:()=>s,kt:()=>g});var r=n(7294);function l(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){l(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function t(e,a){if(null==e)return{};var n,r,l=function(e,a){if(null==e)return{};var n,r,l={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],a.indexOf(n)>=0||(l[n]=e[n]);return l}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var u=r.createContext({}),m=function(e){var a=r.useContext(u),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},s=function(e){var a=m(e.components);return r.createElement(u.Provider,{value:a},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},p=r.forwardRef((function(e,a){var n=e.components,l=e.mdxType,o=e.originalType,u=e.parentName,s=t(e,["components","mdxType","originalType","parentName"]),c=m(n),p=l,g=c["".concat(u,".").concat(p)]||c[p]||d[p]||o;return n?r.createElement(g,i(i({ref:a},s),{},{components:n})):r.createElement(g,i({ref:a},s))}));function g(e,a){var n=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var o=n.length,i=new Array(o);i[0]=p;var t={};for(var u in a)hasOwnProperty.call(a,u)&&(t[u]=a[u]);t.originalType=e,t[c]="string"==typeof e?e:l,i[1]=t;for(var m=2;m<o;m++)i[m]=n[m];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},391:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>m});var r=n(7462),l=(n(7294),n(3905));const o={marp:!0,theme:"default",size:969,paginate:!0},i="02.05 - Manejo de memoria",t={unversionedId:"Lenguaje C/02.05_memoria",id:"Lenguaje C/02.05_memoria",title:"02.05 - Manejo de memoria",description:"Lenguajes Estructurados",source:"@site/docs/02 - Lenguaje C/02.05_memoria.md",sourceDirName:"02 - Lenguaje C",slug:"/Lenguaje C/02.05_memoria",permalink:"/lenguajes-estructurados/docs/Lenguaje C/02.05_memoria",draft:!1,editUrl:"https://github.com/abelranni/lenguajes-estructurados/tree/main/docs/02 - Lenguaje C/02.05_memoria.md",tags:[],version:"current",frontMatter:{marp:!0,theme:"default",size:969,paginate:!0},sidebar:"tutorialSidebar",previous:{title:"02.04 - Repaso de conceptos",permalink:"/lenguajes-estructurados/docs/Lenguaje C/02.04_repaso"},next:{title:"03 - Ejercicios Resueltos",permalink:"/lenguajes-estructurados/docs/category/03---ejercicios-resueltos"}},u={},m=[{value:"Lenguajes Estructurados",id:"lenguajes-estructurados",level:2},{value:"\xbfQu\xe9 es el manejo de memoria?",id:"qu\xe9-es-el-manejo-de-memoria",level:2},{value:"\xbfC\xf3mo se solicita memoria?",id:"c\xf3mo-se-solicita-memoria",level:2},{value:"\xbfC\xf3mo se accede a la memoria?",id:"c\xf3mo-se-accede-a-la-memoria",level:2},{value:"\xbfC\xf3mo se libera memoria?",id:"c\xf3mo-se-libera-memoria",level:2},{value:"Funci\xf3n malloc()",id:"funci\xf3n-malloc",level:2},{value:"La funci\xf3n calloc()",id:"la-funci\xf3n-calloc",level:2},{value:"\xbfC\xf3mo se puede redimensionar un bloque de memoria?",id:"c\xf3mo-se-puede-redimensionar-un-bloque-de-memoria",level:2},{value:"\xbfC\xf3mo se puede copiar la memoria de una estructura?",id:"c\xf3mo-se-puede-copiar-la-memoria-de-una-estructura",level:2},{value:"\xbfC\xf3mo se puede comparar la memoria de dos estructuras?",id:"c\xf3mo-se-puede-comparar-la-memoria-de-dos-estructuras",level:2},{value:"\xbfC\xf3mo se puede limpiar la memoria de una estructura?",id:"c\xf3mo-se-puede-limpiar-la-memoria-de-una-estructura",level:2}],s={toc:m},c="wrapper";function d(e){let{components:a,...n}=e;return(0,l.kt)(c,(0,r.Z)({},s,n,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"0205---manejo-de-memoria"},"02.05 - Manejo de memoria"),(0,l.kt)("h2",{id:"lenguajes-estructurados"},"Lenguajes Estructurados"),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"qu\xe9-es-el-manejo-de-memoria"},"\xbfQu\xe9 es el manejo de memoria?"),(0,l.kt)("p",null,"El manejo de memoria es la forma en que un programa puede solicitar y liberar memoria din\xe1micamente. Nos permite, entre otras cosas, crear estructuras de datos din\xe1micas."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"c\xf3mo-se-solicita-memoria"},"\xbfC\xf3mo se solicita memoria?"),(0,l.kt)("p",null,"Para solicitar memoria, utilizamos la funci\xf3n ",(0,l.kt)("inlineCode",{parentName:"p"},"malloc"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"int *p = malloc(sizeof(int));\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"c\xf3mo-se-accede-a-la-memoria"},"\xbfC\xf3mo se accede a la memoria?"),(0,l.kt)("p",null,"Para acceder a la memoria, utilizamos el operador de indirecci\xf3n ",(0,l.kt)("inlineCode",{parentName:"p"},"*"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"*p = 5;\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"c\xf3mo-se-libera-memoria"},"\xbfC\xf3mo se libera memoria?"),(0,l.kt)("p",null,"Para liberar memoria, utilizamos la funci\xf3n ",(0,l.kt)("inlineCode",{parentName:"p"},"free"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"free(p);\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"funci\xf3n-malloc"},"Funci\xf3n malloc()"),(0,l.kt)("p",null,"La funci\xf3n malloc() en C se utiliza para asignar din\xe1micamente un bloque de memoria en tiempo de ejecuci\xf3n. El bloque de memoria que se asigna puede ser utilizado para almacenar datos de cualquier tipo, como n\xfameros, caracteres, estructuras, matrices y otros objetos."),(0,l.kt)("p",null,"La funci\xf3n malloc() toma un \xfanico argumento, el tama\xf1o en bytes que se desea asignar al bloque de memoria. Devuelve un puntero al inicio del bloque de memoria asignado, o NULL si la asignaci\xf3n de memoria falla."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"A continuaci\xf3n, se presenta un ejemplo b\xe1sico del uso de malloc():"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int* p;\n    p = (int*)malloc(5 * sizeof(int)); // asigna un bloque de memoria para 5 enteros\n\n    if (p == NULL) {\n        printf("No se pudo asignar memoria");\n        return 1;\n    }\n    // se puede utilizar el bloque de memoria para almacenar datos\n    p[0] = 10;\n    p[1] = 20;\n    p[2] = 30;\n    p[3] = 40;\n    p[4] = 50;\n\n    // se debe liberar la memoria asignada con malloc() cuando ya no se necesita\n    free(p);\n    return 0;\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("p",null,"En este ejemplo, malloc() se utiliza para asignar memoria para 5 enteros, y se comprueba si la asignaci\xf3n de memoria ha sido exitosa. Si es as\xed, se utiliza el bloque de memoria asignado para almacenar algunos datos y, finalmente, se libera la memoria asignada con free()."),(0,l.kt)("p",null,"Es importante tener en cuenta que la funci\xf3n malloc() no inicializa los datos en el bloque de memoria asignado, por lo que el programador debe inicializar expl\xedcitamente cualquier dato que se almacene en el bloque de memoria."),(0,l.kt)("p",null,"Adem\xe1s, si se utiliza malloc(), es necesario asegurarse de que la memoria asignada se libere adecuadamente con free() cuando ya no se necesite, para evitar fugas de memoria."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"la-funci\xf3n-calloc"},"La funci\xf3n calloc()"),(0,l.kt)("p",null,"La funci\xf3n calloc() tambi\xe9n se utiliza para asignar memoria din\xe1micamente en tiempo de ejecuci\xf3n, pero difiere de malloc() en la forma en que inicializa el bloque de memoria asignado."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"calloc()")," inicializa el bloque de memoria asignado a ceros, mientras que malloc() no inicializa el bloque de memoria asignado."),(0,l.kt)("p",null,"La funci\xf3n calloc() toma dos argumentos:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"el n\xfamero de elementos que se desean asignar "),(0,l.kt)("li",{parentName:"ul"},"el tama\xf1o de cada elemento en bytes.")),(0,l.kt)("p",null,"Devuelve un puntero al inicio del bloque de memoria asignado, o NULL si la asignaci\xf3n de memoria falla."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"A continuaci\xf3n, se presenta un ejemplo b\xe1sico del uso de calloc():"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int* p;\n\n    // asigna un bloque de memoria para 5 enteros, inicializado a cero\n    p = (int*)calloc(5, sizeof(int)); \n\n    if (p == NULL) {\n        printf("No se pudo asignar memoria");\n        return 1;\n    }\n    // se puede utilizar el bloque de memoria para almacenar datos\n    p[0] = 10;\n    p[1] = 20;\n    p[2] = 30;\n    p[3] = 40;\n    p[4] = 50;\n\n    // se debe liberar la memoria asignada con calloc() cuando ya no se necesita\n    free(p);\n    return 0;\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Es importante tener en cuenta que la funci\xf3n calloc() puede ser m\xe1s lenta que la funci\xf3n malloc(), ya que debe inicializar el bloque de memoria asignado a ceros."),(0,l.kt)("p",null,"Adem\xe1s, como en el caso de malloc(), es necesario asegurarse de que la memoria asignada con calloc() se libere adecuadamente con free() cuando ya no se necesite, para evitar fugas de memoria."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"c\xf3mo-se-puede-redimensionar-un-bloque-de-memoria"},"\xbfC\xf3mo se puede redimensionar un bloque de memoria?"),(0,l.kt)("p",null,"La funci\xf3n realloc() en C se utiliza para cambiar el tama\xf1o de un bloque de memoria que ha sido asignado previamente con malloc(), calloc(), o realloc()."),(0,l.kt)("p",null,"La funci\xf3n toma dos argumentos:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"un puntero al bloque de memoria que se desea cambiar de tama\xf1o"),(0,l.kt)("li",{parentName:"ul"},"el nuevo tama\xf1o en bytes que se desea asignar al bloque.")),(0,l.kt)("p",null,"La funci\xf3n devuelve un puntero al bloque de memoria reci\xe9n asignado, que puede ser el mismo puntero que el que se pas\xf3 como argumento o uno diferente."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"La funci\xf3n realloc() puede ser \xfatil en situaciones en las que se necesita m\xe1s espacio en el bloque de memoria de lo que se asign\xf3 originalmente."),(0,l.kt)("p",null,"En lugar de liberar la memoria y luego volver a asignarla con un tama\xf1o m\xe1s grande, realloc() puede utilizarse para cambiar el tama\xf1o del bloque existente de forma m\xe1s eficiente."),(0,l.kt)("p",null,"Es importante tener en cuenta que la funci\xf3n realloc() puede fallar si no hay suficiente espacio contiguo disponible en la memoria para satisfacer la nueva asignaci\xf3n de tama\xf1o.\nEn ese caso, la funci\xf3n devuelve NULL y no se hace ning\xfan cambio en el bloque de memoria original."),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"c\xf3mo-se-puede-copiar-la-memoria-de-una-estructura"},"\xbfC\xf3mo se puede copiar la memoria de una estructura?"),(0,l.kt)("p",null,"Para copiar la memoria de una estructura, utilizamos la funci\xf3n ",(0,l.kt)("inlineCode",{parentName:"p"},"memcpy"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"memcpy(libro2, libro1, sizeof(struct Libro));\n")),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"c\xf3mo-se-puede-comparar-la-memoria-de-dos-estructuras"},"\xbfC\xf3mo se puede comparar la memoria de dos estructuras?"),(0,l.kt)("p",null,"Para comparar la memoria de dos estructuras, utilizamos la funci\xf3n ",(0,l.kt)("inlineCode",{parentName:"p"},"memcmp"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},'if (memcmp(libro1, libro2, sizeof(struct Libro)) == 0) {\n    printf("Los libros son iguales\\n");\n}\n')),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"c\xf3mo-se-puede-limpiar-la-memoria-de-una-estructura"},"\xbfC\xf3mo se puede limpiar la memoria de una estructura?"),(0,l.kt)("p",null,"Para limpiar la memoria de una estructura, utilizamos la funci\xf3n ",(0,l.kt)("inlineCode",{parentName:"p"},"memset"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-c"},"memset(libro1, 0, sizeof(struct Libro));\n")),(0,l.kt)("hr",null))}d.isMDXComponent=!0}}]);