"use strict";(self.webpackChunklenguajes_estructurados=self.webpackChunklenguajes_estructurados||[]).push([[3617],{3905:(e,n,r)=>{r.d(n,{Zo:()=>l,kt:()=>f});var a=r(7294);function t(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){t(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function c(e,n){if(null==e)return{};var r,a,t=function(e,n){if(null==e)return{};var r,a,t={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var s=a.createContext({}),u=function(e){var n=a.useContext(s),r=n;return e&&(r="function"==typeof e?e(n):o(o({},n),e)),r},l=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=u(r),m=t,f=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return r?a.createElement(f,o(o({ref:n},l),{},{components:r})):a.createElement(f,o({ref:n},l))}));function f(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=r.length,o=new Array(i);o[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[d]="string"==typeof e?e:t,o[1]=c;for(var u=2;u<i;u++)o[u]=r[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},4682:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>c,toc:()=>u});var a=r(7462),t=(r(7294),r(3905));const i={marp:!0,theme:"default",size:969,paginate:!0},o="02.04 - Repaso de conceptos",c={unversionedId:"Lenguaje C/02.04_repaso",id:"Lenguaje C/02.04_repaso",title:"02.04 - Repaso de conceptos",description:"Conceptos b\xe1sicos de C",source:"@site/docs/02 - Lenguaje C/02.04_repaso.md",sourceDirName:"02 - Lenguaje C",slug:"/Lenguaje C/02.04_repaso",permalink:"/lenguajes-estructurados/docs/Lenguaje C/02.04_repaso",draft:!1,editUrl:"https://github.com/abelranni/lenguajes-estructurados/tree/main/docs/02 - Lenguaje C/02.04_repaso.md",tags:[],version:"current",frontMatter:{marp:!0,theme:"default",size:969,paginate:!0},sidebar:"tutorialSidebar",previous:{title:"02.03 - Punteros",permalink:"/lenguajes-estructurados/docs/Lenguaje C/02.03_punteros"},next:{title:"02.05 - Manejo de memoria",permalink:"/lenguajes-estructurados/docs/Lenguaje C/02.05_memoria"}},s={},u=[{value:"Conceptos b\xe1sicos de C",id:"conceptos-b\xe1sicos-de-c",level:2},{value:"Estructuras y punteros",id:"estructuras-y-punteros",level:2},{value:"Ejercicio de Estructuras y punteros",id:"ejercicio-de-estructuras-y-punteros",level:3},{value:"Funciones recursivas",id:"funciones-recursivas",level:2},{value:"Ejercicio de Funciones recursivas",id:"ejercicio-de-funciones-recursivas",level:3},{value:"Manejo de archivos",id:"manejo-de-archivos",level:2},{value:"Ejercicio de Manejo de archivos",id:"ejercicio-de-manejo-de-archivos",level:3},{value:"Memoria din\xe1mica",id:"memoria-din\xe1mica",level:2},{value:"Ejercicio de memoria din\xe1mica",id:"ejercicio-de-memoria-din\xe1mica",level:3}],l={toc:u},d="wrapper";function p(e){let{components:n,...r}=e;return(0,t.kt)(d,(0,a.Z)({},l,r,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"0204---repaso-de-conceptos"},"02.04 - Repaso de conceptos"),(0,t.kt)("h2",{id:"conceptos-b\xe1sicos-de-c"},"Conceptos b\xe1sicos de C"),(0,t.kt)("hr",null),(0,t.kt)("h2",{id:"estructuras-y-punteros"},"Estructuras y punteros"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("p",{parentName:"li"},"Estructuras: Las estructuras en C son una forma de agrupar variables relacionadas bajo un solo nombre. Pueden contener variables de diferentes tipos de datos y facilitan la organizaci\xf3n y manejo de datos en programas m\xe1s grandes.")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("p",{parentName:"li"},"Punteros: Los punteros son variables que almacenan la direcci\xf3n de memoria de otras variables. Permiten manipular la memoria de forma m\xe1s eficiente y son fundamentales para el manejo de memoria din\xe1mica y el paso de argumentos por referencia a funciones."))),(0,t.kt)("hr",null),(0,t.kt)("h3",{id:"ejercicio-de-estructuras-y-punteros"},"Ejercicio de Estructuras y punteros"),(0,t.kt)("p",null,"Crear un programa que represente a una persona utilizando una estructura. La estructura debe contener el nombre, la edad y el g\xe9nero de la persona. Luego, utiliza punteros para modificar y mostrar la informaci\xf3n de la persona."),(0,t.kt)("p",null,"Se debe definir una estructura Persona que agrupa el nombre, la edad y el g\xe9nero de una persona.\nLuego, se utiliza un puntero para modificar y mostrar la informaci\xf3n de la persona."),(0,t.kt)("hr",null),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    char nombre[50];\n    int edad;\n    char genero;\n} Persona;\n\nint main() {\n    Persona p1;\n    Persona *ptr_p1 = &p1;\n\n    strcpy(ptr_p1->nombre, "Juan Perez");\n    ptr_p1->edad = 30;\n    ptr_p1->genero = \'M\';\n\n    printf("Nombre: %s\\n", ptr_p1->nombre);\n    printf("Edad: %d\\n", ptr_p1->edad);\n    printf("Genero: %c\\n", ptr_p1->genero);\n\n    return 0;\n}\n')),(0,t.kt)("hr",null),(0,t.kt)("h2",{id:"funciones-recursivas"},"Funciones recursivas"),(0,t.kt)("p",null,"La recursividad es un concepto en el que una funci\xf3n se llama a s\xed misma como parte de su ejecuci\xf3n.\nPara que una funci\xf3n recursiva no entre en un bucle infinito, debe tener una condici\xf3n base que detenga la recursi\xf3n."),(0,t.kt)("h3",{id:"ejercicio-de-funciones-recursivas"},"Ejercicio de Funciones recursivas"),(0,t.kt)("p",null,"Escribir una funci\xf3n recursiva que calcule el factorial de un n\xfamero entero. La funci\xf3n se debe llamar a s\xed misma con un valor decreciente hasta llegar a la condici\xf3n base (n == 0), momento en el que se detiene la recursi\xf3n y se devuelve el resultado."),(0,t.kt)("hr",null),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\nint factorial(int n);\n\nint main() {\n    int numero;\n    printf("Ingrese un numero entero: ");\n    scanf("%d", &numero);\n\n    printf("El factorial de %d es: %d\\n", numero, factorial(numero));\n    return 0;\n}\n')),(0,t.kt)("hr",null),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-c"},"int factorial(int n) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n")),(0,t.kt)("h2",{id:"manejo-de-archivos"},"Manejo de archivos"),(0,t.kt)("p",null,"El manejo de archivos en C permite leer y escribir datos en archivos externos, lo que es \xfatil para almacenar y recuperar informaci\xf3n de manera persistente. Las funciones principales para el manejo de archivos incluyen fopen, fclose, fread, fwrite, fscanf y fprintf."),(0,t.kt)("hr",null),(0,t.kt)("h3",{id:"ejercicio-de-manejo-de-archivos"},"Ejercicio de Manejo de archivos"),(0,t.kt)("p",null,"Crear un programa que escriba en un archivo de texto los n\xfameros del 1 al 10 y luego los lea y muestre por pantalla."),(0,t.kt)("hr",null),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n\nint main() {\n    FILE *archivo;\n\n    // Escribir en el archivo\n    archivo = fopen("numeros.txt", "w");\n    for (int i = 1; i <= 10; i++) {\n        fprintf(archivo, "%d\\n", i);\n    }\n    fclose(archivo);\n\n    // Leer del archivo\n    archivo = fopen("numeros.txt", "r");\n    int numero;\n    printf("Numeros del archivo:\\n");\n    while (fscanf(archivo, "%d", &numero) != EOF) {\n        printf("%d\\n", numero);\n    }\n    fclose(archivo);\n\n    return 0;\n}\n')),(0,t.kt)("hr",null),(0,t.kt)("h2",{id:"memoria-din\xe1mica"},"Memoria din\xe1mica"),(0,t.kt)("p",null,"La memoria din\xe1mica es una t\xe9cnica que permite asignar y liberar memoria en tiempo de ejecuci\xf3n seg\xfan las necesidades del programa. Las funciones malloc, calloc, realloc y free se utilizan para manejar la memoria din\xe1mica en C."),(0,t.kt)("h3",{id:"ejercicio-de-memoria-din\xe1mica"},"Ejercicio de memoria din\xe1mica"),(0,t.kt)("p",null,"Escribir un programa que pida al usuario la cantidad de n\xfameros que desea ingresar, y luego utilice memoria din\xe1mica para almacenar y mostrar estos n\xfameros."),(0,t.kt)("hr",null),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int cantidad;\n    printf("Ingrese la cantidad de numeros: ");\n    scanf("%d", &cantidad);\n\n    int *numeros = (int *) malloc(cantidad * sizeof(int));\n\n    for (int i = 0; i < cantidad; i++) {\n        printf("Ingrese el numero %d: ", i + 1);\n        scanf("%d", &numeros[i]);\n    }\n\n    printf("Numeros ingresados:\\n");\n    for (int i = 0; i < cantidad; i++) {\n        printf("%d\\n", numeros[i]);\n    }\n\n    free(numeros);\n    return 0;\n}\n\n')))}p.isMDXComponent=!0}}]);