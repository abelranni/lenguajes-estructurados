"use strict";(self.webpackChunklenguajes_estructurados=self.webpackChunklenguajes_estructurados||[]).push([[8665],{3905:(e,a,n)=>{n.d(a,{Zo:()=>s,kt:()=>f});var l=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);a&&(l=l.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,l)}return n}function t(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,l,r=function(e,a){if(null==e)return{};var n,l,r={},i=Object.keys(e);for(l=0;l<i.length;l++)n=i[l],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)n=i[l],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=l.createContext({}),c=function(e){var a=l.useContext(u),n=a;return e&&(n="function"==typeof e?e(a):t(t({},a),e)),n},s=function(e){var a=c(e.components);return l.createElement(u.Provider,{value:a},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return l.createElement(l.Fragment,{},a)}},m=l.forwardRef((function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,f=d["".concat(u,".").concat(m)]||d[m]||p[m]||i;return n?l.createElement(f,t(t({ref:a},s),{},{components:n})):l.createElement(f,t({ref:a},s))}));function f(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,t=new Array(i);t[0]=m;var o={};for(var u in a)hasOwnProperty.call(a,u)&&(o[u]=a[u]);o.originalType=e,o[d]="string"==typeof e?e:r,t[1]=o;for(var c=2;c<i;c++)t[c]=n[c];return l.createElement.apply(null,t)}return l.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2893:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>u,contentTitle:()=>t,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var l=n(7462),r=(n(7294),n(3905));const i={marp:!0,theme:"default",size:969,paginate:!0,math:!0},t="03.02 - Fractales de Julia",o={unversionedId:"Ejercicios Resueltos/03.02_fractales_julia",id:"Ejercicios Resueltos/03.02_fractales_julia",title:"03.02 - Fractales de Julia",description:"Lenguajes Estructurados",source:"@site/docs/03 - Ejercicios Resueltos/03.02_fractales_julia.md",sourceDirName:"03 - Ejercicios Resueltos",slug:"/Ejercicios Resueltos/03.02_fractales_julia",permalink:"/lenguajes-estructurados/docs/Ejercicios Resueltos/03.02_fractales_julia",draft:!1,editUrl:"https://github.com/abelranni/lenguajes-estructurados/tree/main/docs/03 - Ejercicios Resueltos/03.02_fractales_julia.md",tags:[],version:"current",frontMatter:{marp:!0,theme:"default",size:969,paginate:!0,math:!0},sidebar:"tutorialSidebar",previous:{title:"03.01 - Juego de la vida de Conway",permalink:"/lenguajes-estructurados/docs/Ejercicios Resueltos/03.01_life_conway"},next:{title:"03.03.A - Juego de Snake en C",permalink:"/lenguajes-estructurados/docs/Ejercicios Resueltos/03.03.A_snake"}},u={},c=[{value:"Lenguajes Estructurados",id:"lenguajes-estructurados",level:2},{value:"Introducci\xf3n a fractales de Julia",id:"introducci\xf3n-a-fractales-de-julia",level:2},{value:"SDL (Simple DirectMedia Layer)",id:"sdl-simple-directmedia-layer",level:2},{value:"Generaci\xf3n de fractales de Julia utilizando punteros y SDL",id:"generaci\xf3n-de-fractales-de-julia-utilizando-punteros-y-sdl",level:2},{value:"Inclusi\xf3n de cabeceras y declaraci\xf3n de funci\xf3n de utilidad",id:"inclusi\xf3n-de-cabeceras-y-declaraci\xf3n-de-funci\xf3n-de-utilidad",level:2},{value:"Inicializaci\xf3n de SDL y creaci\xf3n de la ventana",id:"inicializaci\xf3n-de-sdl-y-creaci\xf3n-de-la-ventana",level:2},{value:"Generaci\xf3n del fractal de Julia",id:"generaci\xf3n-del-fractal-de-julia",level:2},{value:"Actualizaci\xf3n de la ventana",id:"actualizaci\xf3n-de-la-ventana",level:3},{value:"Bucle principal del programa",id:"bucle-principal-del-programa",level:2},{value:"Limpieza y finalizaci\xf3n",id:"limpieza-y-finalizaci\xf3n",level:2},{value:"Compilaci\xf3n y ejecuci\xf3n",id:"compilaci\xf3n-y-ejecuci\xf3n",level:2},{value:"Apendice I : N\xfameros complejos en C",id:"apendice-i--n\xfameros-complejos-en-c",level:2},{value:"Apendice II : SDL",id:"apendice-ii--sdl",level:2},{value:"SDL_Surface",id:"sdl_surface",level:3},{value:"Coloreado del fractal de Julia",id:"coloreado-del-fractal-de-julia",level:2},{value:"Ejemplo de SDL en C",id:"ejemplo-de-sdl-en-c",level:2},{value:"Referencias",id:"referencias",level:2},{value:"Python",id:"python",level:2}],s={toc:c},d="wrapper";function p(e){let{components:a,...n}=e;return(0,r.kt)(d,(0,l.Z)({},s,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0302---fractales-de-julia"},"03.02 - Fractales de Julia"),(0,r.kt)("h2",{id:"lenguajes-estructurados"},"Lenguajes Estructurados"),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"introducci\xf3n-a-fractales-de-julia"},"Introducci\xf3n a fractales de Julia"),(0,r.kt)("p",null,"Los fractales son figuras geom\xe9tricas que se repiten a diferentes escalas y exhiben autosimilaridad. Se pueden encontrar en la naturaleza, el arte y tienen aplicaciones en matem\xe1ticas, f\xedsica y ciencias de la computaci\xf3n.\nUno de los fractales m\xe1s conocidos es el conjunto de Julia, que es un conjunto de n\xfameros complejos que, al iterar a trav\xe9s de una funci\xf3n cuadr\xe1tica, no tienden hacia infinito.\nEl conjunto de Mandelbrot es un subconjunto del conjunto de Julia que utiliza una funci\xf3n cuadr\xe1tica espec\xedfica."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"sdl-simple-directmedia-layer"},"SDL (Simple DirectMedia Layer)"),(0,r.kt)("p",null,"SDL es una biblioteca de gr\xe1ficos en C que permite la representaci\xf3n de im\xe1genes, el manejo de eventos y la interacci\xf3n con dispositivos de entrada.\nEs multiplataforma y se utiliza com\xfanmente para el desarrollo de videojuegos y aplicaciones gr\xe1ficas."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"generaci\xf3n-de-fractales-de-julia-utilizando-punteros-y-sdl"},"Generaci\xf3n de fractales de Julia utilizando punteros y SDL"),(0,r.kt)("p",null,"Para generar un fractal de Julia, necesitamos iterar a trav\xe9s de cada p\xedxel en una imagen y aplicar la funci\xf3n cuadr\xe1tica:"),(0,r.kt)("p",null,"$$Z(n+1) = Z(n)^2 + C$$"),(0,r.kt)("p",null,"Aqu\xed, Z(n) es un n\xfamero complejo que representa la posici\xf3n actual del p\xedxel en el plano complejo, Z(n+1) es el resultado de la funci\xf3n cuadr\xe1tica y C es un n\xfamero complejo constante que determina la forma del fractal de Julia."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"El algoritmo b\xe1sico para generar un fractal de Julia es el siguiente:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Para cada p\xedxel en la imagen, convertir sus coordenadas a n\xfameros complejos en un rango espec\xedfico (por ejemplo, -2 < Re < 2 y -2 < Im < 2)."),(0,r.kt)("li",{parentName:"ul"},"Aplicar la funci\xf3n cuadr\xe1tica de Julia a cada n\xfamero complejo un n\xfamero determinado de iteraciones o hasta que su magnitud supere un umbral (por ejemplo, 1000 iteraciones y umbral de 2)."),(0,r.kt)("li",{parentName:"ul"},"Colorear el p\xedxel seg\xfan el n\xfamero de iteraciones que tom\xf3 para superar el umbral."),(0,r.kt)("li",{parentName:"ul"},"Para utilizar SDL y punteros en este proceso, primero hace falta crear una ventana y una superficie para representar gr\xe1ficamente el fractal.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"inclusi\xf3n-de-cabeceras-y-declaraci\xf3n-de-funci\xf3n-de-utilidad"},"Inclusi\xf3n de cabeceras y declaraci\xf3n de funci\xf3n de utilidad"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include <SDL.h>\n#include <complex.h>\n#include <stdbool.h>\n\ndouble map_range(double value, double in_min, double in_max, double out_min, double out_max) {\n    return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n")),(0,r.kt)("p",null,"Este bloque incluye las cabeceras necesarias para usar SDL, n\xfameros complejos y tipos booleanos en el programa.\nLa funci\xf3n map_range toma un valor en un rango dado (in_min, in_max) y lo mapea linealmente a otro rango (out_min, out_max). Se utiliza para convertir las coordenadas de p\xedxeles en valores de n\xfameros complejos en el espacio del fractal."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"inicializaci\xf3n-de-sdl-y-creaci\xf3n-de-la-ventana"},"Inicializaci\xf3n de SDL y creaci\xf3n de la ventana"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'if (SDL_Init(SDL_INIT_VIDEO) < 0) {\n    SDL_Log("No se pudo inicializar SDL: %s", SDL_GetError());\n    return 1;\n}\n\nSDL_Window *window = SDL_CreateWindow("Fractal de Julia", \n    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_SHOWN);\n\nif (!window) {\n    SDL_Log("No se pudo crear la ventana: %s", SDL_GetError());\n    SDL_Quit();\n    return 1;\n}\nSDL_Surface *surface = SDL_GetWindowSurface(window);\n\n')),(0,r.kt)("p",null,"Este bloque inicializa SDL, crea una ventana y obtiene una superficie asociada a la ventana. La superficie se utilizar\xe1 para dibujar el fractal de Julia."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"generaci\xf3n-del-fractal-de-julia"},"Generaci\xf3n del fractal de Julia"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n        double real = map_range(x, 0, width, -2.0, 2.0);\n        double imag = map_range(y, 0, height, -2.0, 2.0);\n        complex double z = real + imag * I;\n        complex double c = -0.8 + 0.156 * I;\n\n        int iterations = 0;\n        while (cabs(z) < 2 && iterations < max_iterations) {\n            z = z * z + c;\n            iterations++;\n        }\n        uint32_t color = SDL_MapRGB(surface->format, iterations % 256, 0, (iterations * 2) % 256);\n        uint32_t *pixels = (uint32_t *)surface->pixels;\n        pixels[y * width + x] = color;\n    }\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"El bloque anterior itera sobre todos los p\xedxeles de la superficie, convierte sus coordenadas en n\xfameros complejos y aplica el algoritmo del fractal de Julia. Los p\xedxeles se colorean en funci\xf3n del n\xfamero de iteraciones que tomaron para superar un umbral de magnitud."),(0,r.kt)("h3",{id:"actualizaci\xf3n-de-la-ventana"},"Actualizaci\xf3n de la ventana"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"SDL_UpdateWindowSurface(window);\n")),(0,r.kt)("p",null,"Este bloque actualiza la ventana para que muestre la superficie con el fractal de Julia generado."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"bucle-principal-del-programa"},"Bucle principal del programa"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"SDL_Event event;\nbool running = true;\n\nwhile (running) {\n    while (SDL_PollEvent(&event)) {\n        if (event.type == SDL_QUIT) {\n            running = false;\n        }\n    }\n}\n\n")),(0,r.kt)("p",null,"Este bloque contiene el bucle principal del programa que maneja los eventos, como el cierre de la ventana. Cuando se recibe el evento SDL_QUIT, se establece la variable running en false, lo que hace que el bucle termine y el programa finalice."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"limpieza-y-finalizaci\xf3n"},"Limpieza y finalizaci\xf3n"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"SDL_DestroyWindow(window);\nSDL_Quit();\nreturn 0;\n\n")),(0,r.kt)("p",null,"Este bloque limpia los recursos de SDL, destruye la ventana y finaliza el programa."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"compilaci\xf3n-y-ejecuci\xf3n"},"Compilaci\xf3n y ejecuci\xf3n"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"gcc -o julia julia.c -lSDL2\n./julia\n")),(0,r.kt)("p",null,"Este bloque compila el programa y lo ejecuta."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"apendice-i--n\xfameros-complejos-en-c"},"Apendice I : N\xfameros complejos en C"),(0,r.kt)("p",null,'Los n\xfameros complejos se pueden declarar y manipular utilizando el tipo de datos "complex", que se define en la biblioteca est\xe1ndar "complex.h".'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Se pueden representar como dobles o como flotantes."),(0,r.kt)("li",{parentName:"ul"},"Para representar n\xfameros complejos como dobles, se utiliza la estructura complex double."),(0,r.kt)("li",{parentName:"ul"},"Para representar n\xfameros complejos como flotantes, se utiliza la estructura complex float.")),(0,r.kt)("p",null,"La sintaxis para declarar un n\xfamero complejo es la siguiente:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include <complex.h>\ncomplex double z;\n\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,'En este ejemplo, se declara una variable "z" de tipo "complex double", que representa un n\xfamero complejo con una parte real y una parte imaginaria de tipo "double".'),(0,r.kt)("p",null,'Para asignar valores a las partes real e imaginaria de un n\xfamero complejo, se pueden utilizar las funciones "creal" e "cimag", respectivamente.'),(0,r.kt)("p",null,"La sintaxis para asignar valores a un n\xfamero complejo es la siguiente:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include <complex.h>\n\ncomplex double z;\ndouble a = 2.5;\ndouble b = 1.5;\n\nz = a + b * I;\n\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,'En este ejemplo, se asigna el valor 2.5 a la parte real del n\xfamero complejo "z" y el valor 1.5 a la parte imaginaria ',(0,r.kt)("strong",{parentName:"p"},'utilizando la constante "I" de la biblioteca "complex.h", que representa la unidad imaginaria (\u221a(-1))')," ."),(0,r.kt)("p",null,'Una vez que se ha declarado y asignado valores a un n\xfamero complejo, se pueden realizar operaciones aritm\xe9ticas con \xe9l utilizando los operadores aritm\xe9ticos convencionales (+, -, *, /) y las funciones de la biblioteca "complex.h", como "cabs" (para obtener el valor absoluto del n\xfamero complejo) o "conj" (para obtener el conjugado del n\xfamero complejo).'),(0,r.kt)("p",null,"A continuaci\xf3n se muestran algunos ejemplos de operaciones aritm\xe9ticas con n\xfameros complejos en C:"),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <complex.h>\n\nint main() {\n    complex double z1 = 2.0 + 3.0 * I;\n    complex double z2 = 1.0 - 1.0 * I;\n\n    printf("Suma: %f + %f i\\n", creal(z1 + z2), cimag(z1 + z2));\n    printf("Resta: %f + %f i\\n", creal(z1 - z2), cimag(z1 - z2));\n    printf("Producto: %f + %f i\\n", creal(z1 * z2), cimag(z1 * z2));\n    printf("Cociente: %f + %f i\\n", creal(z1 / z2), cimag(z1 / z2));\n    printf("Valor absoluto de z1: %f\\n", cabs(z1));\n    printf("Conjugado de z1: %f + %f i\\n", creal(conj(z1)), cimag(conj(z1)));\n\n    return 0;\n}\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"apendice-ii--sdl"},"Apendice II : SDL"),(0,r.kt)("p",null,"SDL es una biblioteca de desarrollo de videojuegos y multimedia que se puede utilizar para crear aplicaciones gr\xe1ficas. SDL se puede utilizar en C, C++ y otros lenguajes de programaci\xf3n."),(0,r.kt)("h3",{id:"sdl_surface"},"SDL_Surface"),(0,r.kt)("p",null,"SDL_Surface es una estructura que representa una superficie de dibujo. Una superficie de dibujo es una matriz de p\xedxeles que se puede dibujar en una ventana. Una superficie de dibujo se puede utilizar para dibujar formas geom\xe9tricas, im\xe1genes y texto."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"coloreado-del-fractal-de-julia"},"Coloreado del fractal de Julia"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"uint32_t *pixels = (uint32_t *)surface->pixels;\n")),(0,r.kt)("p",null,"En esta l\xednea, se declara un puntero a un entero sin signo de 32 bits llamado pixels. Luego, se asigna el puntero al arreglo de p\xedxeles de la superficie (surface->pixels). El puntero se convierte expl\xedcitamente a (uint32_t *) porque surface->pixels es un puntero a void. Esto se hace para asegurar que el puntero apunte a un arreglo de enteros sin signo de 32 bits (donde cada entero representa un p\xedxel en la superficie) en lugar de un puntero a un tipo de dato desconocido."),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"pixels[y * width + x] = color;\n")),(0,r.kt)("p",null,"En esta l\xednea, se establece el color del p\xedxel en las coordenadas (x, y) en la superficie de la ventana.\nPara hacer esto, se utiliza la f\xf3rmula y * width + x para calcular el \xedndice lineal del p\xedxel en el arreglo unidimensional de p\xedxeles. La variable ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," se multiplica por la anchura (width) para avanzar a la fila correspondiente en la superficie de la ventana y, luego, se suma la variable x para desplazarse a la columna correcta. Una vez que se obtiene el \xedndice lineal, se asigna el valor color al p\xedxel en esa posici\xf3n en el arreglo pixels."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"El valor de color es calculado en la l\xednea anterior:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"uint32_t color = SDL_MapRGB(surface->format, iterations % 256, 0, (iterations * 2) % 256);\n")),(0,r.kt)("p",null,"Esta l\xednea crea un valor de color de 32 bits utilizando la funci\xf3n SDL_MapRGB. La funci\xf3n toma como argumentos el formato de color de la superficie (surface->format) y los componentes de color rojo, verde y azul (RGB). En este caso, el componente rojo se calcula como iterations % 256, el componente verde se establece en 0, y el componente azul se calcula como (iterations * 2) % 256.\nEstos c\xe1lculos modulares aseguran que los valores de los componentes de color est\xe9n siempre en el rango ","[0, 255]",". Los componentes de color se basan en el n\xfamero de iteraciones realizadas en el bucle del fractal de Julia, lo que genera una representaci\xf3n visual \xfanica y colorida del fractal."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Despu\xe9s de establecer el color de cada p\xedxel en la superficie de la ventana, se llama a la funci\xf3n "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"SDL_UpdateWindowSurface(window);\n")),(0,r.kt)("p",null,"Esta funci\xf3n actualiza la ventana con los cambios realizados en la superficie. En otras palabras, hace que los p\xedxeles coloreados sean visibles en la ventana de la aplicaci\xf3n."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"ejemplo-de-sdl-en-c"},"Ejemplo de SDL en C"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},'#include <SDL.h>\n\n\nint main() {\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) {\n        SDL_Log("No se pudo inicializar SDL: %s", SDL_GetError());\n        return 1;\n    }\n\n    SDL_Window *window = SDL_CreateWindow("Hola mundo", \n        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_SHOWN);\n\n    if (!window) {\n        SDL_Log("No se pudo crear la ventana: %s", SDL_GetError());\n        SDL_Quit();\n        return 1;\n    }\n\n    SDL_Event event;\n    bool running = true;\n\n    while (running) {\n        while (SDL_PollEvent(&event)) {\n            if (event.type == SDL_QUIT) {\n                running = false;\n            }\n        }\n    }\n\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n    return 0;\n}\n')),(0,r.kt)("hr",null),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"referencias"},"Referencias"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://lazyfoo.net/tutorials/SDL/index.php"},"SDL Tutorial"))),(0,r.kt)("hr",null),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"python"},"Python"),(0,r.kt)("p",null,"La l\xednea de c\xf3digo"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"plt.imshow(iter_count, cmap='viridis', extent=[xmin, xmax, ymin, ymax])\n")),(0,r.kt)("p",null,"se utiliza para mostrar una imagen en la ventana del gr\xe1fico utilizando la funci\xf3n imshow de la biblioteca matplotlib."),(0,r.kt)("p",null,"Los argumentos que se le pasan a esta funci\xf3n son los siguientes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"iter_count: Esta es la matriz que contiene el n\xfamero de iteraciones que se han realizado para cada punto del plano complejo. Esta matriz se ha generado previamente en el c\xf3digo utilizando un bucle for y la funci\xf3n julia(z, c) que define el fractal de Julia.")),(0,r.kt)("hr",null),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"cmap='viridis': Este es el mapa de colores que se utilizar\xe1 para representar los diferentes valores en la matriz iter_count. En este caso, se utiliza el mapa de colores \"viridis\", que es un mapa de colores predefinido en matplotlib que va desde el color azul oscuro para los valores m\xe1s peque\xf1os, hasta el color amarillo claro para los valores m\xe1s grandes.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"extent=","[xmin, xmax, ymin, ymax]",": Este argumento se utiliza para definir los l\xedmites del eje x e y en el gr\xe1fico. Los valores xmin, xmax, ymin e ymax se han definido previamente en el c\xf3digo para definir los l\xedmites del plano complejo que se est\xe1 dibujando."))),(0,r.kt)("hr",null),(0,r.kt)("p",null,"En resumen, la l\xednea de c\xf3digo plt.imshow(iter_count, cmap='viridis', extent=","[xmin, xmax, ymin, ymax]",') muestra la matriz iter_count en una imagen utilizando el mapa de colores "viridis" y los l\xedmites del eje x e y definidos por xmin, xmax, ymin e ymax.'),(0,r.kt)("hr",null))}p.isMDXComponent=!0}}]);